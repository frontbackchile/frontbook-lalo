<!DOCTYPE html>
<html lang="es">
  <head>
    <title>Frontbook</title>
    <meta charset="UTF-8">
    <link href="img/icons/favicon.png" rel="shortcut icon">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href="css/main.css?v=94766" rel="stylesheet" type="text/css">
    <meta name="theme-color" content="#2A7FFF">
    <script src="js/main.js?v=94766" type="text/javascript"></script>
    <meta name="description" content="Desarrollo web Frontend y Backend a tu disposición. Cuenta con nosotros si tienes un proyecto web en mente o necesitas apoyo en desarrollo Frontend, Backend y Diseño.">
    <!-- Meta tags facebook-->
    <meta property="og:title" content="Desarrollo web Frontend y Backend a tu disposición">
    <meta property="og:description" content="Cuenta con nosotros si tienes un proyecto web en mente o necesitas apoyo en desarrollo Frontend, Backend y Diseño.">
    <meta property="og:image" content="img/share.jpg">
    <!-- Meta tags twitter cards-->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Desarrollo web Frontend y Backend a tu disposición">
    <meta name="twitter:description" content="Cuenta con nosotros si tienes un proyecto web en mente o necesitas apoyo en desarrollo Frontend, Backend y Diseño.">
    <!--[if lt IE 9]> <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script> <![endif]-->
    
  </head>
  <body>
    <header>
      <div class="header__primary">
        <div class="header__wrap">
          <div class="header__inner">
            <div class="header__logo header__logo--white"><a href="index.html"><img src="img/icons/logo-frontback-white.png"></a></div>
            <div class="header__logo header__logo--color"><a href="index.html"><img src="img/icons/logo-frontback-color.png"></a></div>
            <div class="header__nav">
              <div class="header__nav__bg"></div>
              <div class="header__nav__nav">
                <div class="header__nav__close">
                  <div></div>
                  <div></div>
                </div>
                <div class="header__nav__back">
                  <div></div>
                  <div></div>
                  <div></div>
                </div>
                <nav>
                  <ul>
                    <li><a href="index.html">Inicio</a></li>
                    <li><a href="html.html">HTML</a></li>
                    <li><a href="css.html">CSS</a></li>
                    <li><a href="javascript.html">Javascript</a></li>
                  </ul>
                </nav>
              </div>
            </div>
            <div class="header__right">
              <div class="header__item">
                <div class="header__switch">
                  <input type="checkbox" id="switchdark">
                  <label for="switchdark">Toggle</label>
                </div>
              </div>
              <div class="header__item header__item--ham">
                <div class="header__ham"><span></span><span></span><span></span></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </header>
    <div id="sections">
      <section class="section--diccionary">
        <div class="section__search"><img src="img/icons/search.svg"></div>
        <div class="section__wrap">
          <div class="section__body">
            <aside>
              <div class="aside__wrap">
                <div class="aside__close"><span class="fa fa-close"></span></div>
                <div class="aside__header">
                  <div class="aside__icon"><img src="img/icons/js.png"></div>
                </div>
                <div class="aside__body">
                  <ul>
                    <li><a data-goto=".section__theme--0" class="current">¿Que es JAVASCRIPT?</a></li>
                    <li><a data-goto=".section__theme--1">Consola</a></li>
                    <li><a data-goto=".section__theme--2">Variables</a></li>
                    <li><a data-goto=".section__theme--3">Constantes</a></li>
                    <li><a data-goto=".section__theme--4">Tipos de datos</a></li>
                    <li><a data-goto=".section__theme--5">Condicionales </a></li>
                    <li><a data-goto=".section__theme--6">Bucles</a></li>
                    <li><a data-goto=".section__theme--7">Funciónes básicas</a></li>
                    <li><a data-goto=".section__theme--8">Objetos basicos</a></li>
                    <li><a data-goto=".section__theme--9">Variables numéricas (NUMBER)</a></li>
                    <li><a data-goto=".section__theme--10">Operaciones matemáticas (Math)</a></li>
                    <li><a data-goto=".section__theme--11">Variables de texto (String)</a></li>
                    <li><a data-goto=".section__theme--12">Funciones Avanzado</a></li>
                    <li><a data-goto=".section__theme--13">Litora nec aenean</a></li>
                    <li><a data-goto=".section__theme--14">Sed mattis ligula</a></li>
                    <li><a data-goto=".section__theme--15">Quisque netus semper</a></li>
                    <li><a data-goto=".section__theme--16">Imperdiet ornare orci</a></li>
                    <li><a data-goto=".section__theme--17">Fringilla nibh quisque</a></li>
                    <li><a data-goto=".section__theme--18">Convallis diam tempus</a></li>
                    <li><a data-goto=".section__theme--19">Dapibus aenean suspendisse</a></li>
                  </ul>
                </div>
              </div>
            </aside>
            <div class="section__book">
              <div class="section__content">
                <div class="section__theme section__theme--0">
                  <h2>¿Que es JAVASCRIPT?</h2>
                  <p>Javascript es un lenguaje de programación, o lo que es lo mismo, un mecanismo con el que podemos decirle a nuestro navegador que tareas debe realizar, en que orden y cuantas veces (por ejemplo).</p>
                  <p>Muchas de las tareas que realizamos con HTML y CSS se podrían realizar con Javascript. De hecho, es muy probable que al principio nos parezca que es mucho más complicado hacerlo con Javascript, y que por lo tanto no merece la pena. Sin embargo, con el tiempo veremos que Javascript nos ofrece una mayor flexibilidad y un abanico de posibilidades más grande, y que bien usadas, pueden ahorrarnos bastante tiempo.</p>
                </div>
                <div class="section__theme section__theme--1">
                  <h2>Consola</h2>
                  <p>En esta consola, podemos escribir funciones o sentencias de Javascript que estarán actuando en la página que se encuentra en la pestaña actual del navegador. De esta forma podremos observar los resultados que nos devuelve en la consola al realizar diferentes acciones. Para ello, vamos a ver algunas bases:</p>
                  <blockquote>También se puede utilizar directamente el atajo de teclado CTRL+SHIFT+J, que en algunos navegadores nos lleva directamente a la consola.</blockquote>
                  <pre><code class="language-javascript">console.log()	//    Muestra la información proporcionada en la consola Javascript.
console.info()	//Equivalente al anterior. Se utiliza para mensajes de información.
console.warn()	//Muestra información de advertencia. Aparece en amarillo.
console.error()	//Muestra información de error. Aparece en rojo.
console.clear()	//Limpia la consola. Equivalente a pulsar CTRL+L o escribir clear().
console.log("%c¡Hola Manz!","background:linear-gradient(#000, #555); color:#fff; padding: 5px 10px;"); // Estilos en la consola</code></pre>
                </div>
                <div class="section__theme section__theme--2">
                  <h2>Variables</h2>
                  <p>En programación, las variables son espacios donde se puede guardar información y asociarla a un determinado nombre. De esta forma, cada vez que se consulte ese nombre posteriormente, te devolverá la información que contiene. La primera vez que se realiza este paso se suele llamar inicializar una variable.</p>
                  <p>En Javascript, si una variable no está inicializada, contendrá un valor especial: undefined, que significa que su valor no está definido aún, o lo que es lo mismo, que no contiene información:</p>
                  <pre><code class="language-javascript">var a; // Declaramos una variable "a", pero no le asociamos ningún contenido.
var b = 0; // Declaramos una variable de nombre "b", y le asociamos el número 0.
console.log(b); // Muestra 0 (el valor guardado en la variable "b")
console.log(a); // Muestra "undefined" (no hay valor guardado en la variable "a")</code></pre>
                  <blockquote>Las mayúsculas y minúsculas en los nombres de las variables de Javascript importan. No es lo mismo una variable llamada precio que una variable llamada Precio, pueden contener valores diferentes.</blockquote>
                  <p>Si tenemos que declarar muchas variables consecutivas, una buena práctica suele ser escribir sólo el primer var y separar por comas las diferentes variables con sus respectivos contenidos (método 3). Aunque se podría escribir todo en una misma línea (método 2), con el último método el código es mucho más fácil de leer:</p>
                  <pre><code class="language-javascript">// Método 1: Declaración de variables de forma independiente
var a = 3;
var c = 1;
var d = 2;
// Método 2: Declaración masiva de variables con el mismo var
var a = 3,
c = 1,
d = 2;
// Método 3: Igual al anterior, pero mejorando la legibilidad del código
var a = 3,
c = 1,
d = 2;</code></pre>
                  <blockquote>Como su propio nombre indica, una variable puede variar su contenido, ya que aunque contenga una cierta información, se puede volver a cambiar. A esta acción ya no se le llama inicializar una variable, sino declarar una variable (o más concretamente, redeclarar). En el código se puede diferenciar porque se omite el var:</blockquote>
                  <pre><code class="language-javascript">var a = 40; // Inicializamos la variable "a" al valor 40.
a = 50; // Ahora, hemos declarado que pasa a contener 50 en lugar de 40.</code></pre>
                  <p>En las versiones modernas de Javascript (ES6 o ECMAScript 2015) o posteriores, se introduce la palabra clave let en sustitución de var. Con ella, en lugar de utilizar los ámbitos globales y a nivel de función (var), utilizamos los ámbitos clásicos de programación: ámbito global y ámbito local.</p>
                  <p>La diferencia se puede ver claramente en el uso de un bucle for con var y con let:</p>
                  <pre><code class="language-javascript">/** Opción 1: Bucle con let **/
console.log("Antes: ", p);    // Antes: undefined
for (let p = 0; p < 3; p++)
	console.log("- ", p);      // Durante: 0, 1, 2
console.log("Después: ", p);  // Después: undefined
/** Opción 2: Bucle con var **/
console.log("Antes: ", p);    // Antes: undefined
for (var p = 0; p < 3; p++)
	console.log("- ", p);      // Durante: 0, 1, 2
console.log("Después: ", p);  // Después: 3 (WTF!)</code></pre>
                  <p>Vemos que utilizando let la variable p sólo existe dentro del bucle, ámbito local, mientras que utilizando var la variable p sigue existiendo fuera del bucle, ya que debe tener un ámbito global o a nivel de función.</p>
                </div>
                <div class="section__theme section__theme--3">
                  <h2>Constantes</h2>
                  <p>De forma tradicional, Javascript no incorporaba constantes. Sin embargo, en ECMAScript 2015 (ES6) se añade la palabra clave const, que inicializada con un valor concreto, permite crear variables con valores que no pueden ser cambiados.</p>
                  <pre><code class="language-javascript">const NAME = "Manz";
console.log(NAME);</code></pre>
                  <p>En el ejemplo anterior vemos un ejemplo de const, que funciona de forma parecida a let. Una buena práctica es escribir el nombre de la constante en mayúsculas, para identificar rápidamente que se trata de una constante y no una variable, cuando leemos código ajeno.</p>
                  <blockquote>Realmente, las constantes de Javascript son variables inicializadas a un valor específico y que no pueden redeclararse. No confundir con valores inmutables, ya que como veremos posteriormente, los objetos si pueden ser modificados aún siendo constantes.</blockquote>
                </div>
                <div class="section__theme section__theme--4">
                  <h2>Tipos de datos</h2>
                  <p>En Javascript disponemos de los siguientes tipos de datos:</p>
                  <pre><code class="language-javascript">var edad = 50                   // Valor numérico (enteros, decimales, etc...)
var nombre = "Eduardo"          // Valor de texto (cadenas de texto, carácteres, etc...)
var bolean = true               // Valor booleano (valores verdadero o falso)
var undefined = undefined       // Valor sin definir (variable sin inicializar)
var funcion = function() {}     // Función (función guardada en una variable)
var objeto = {}                 // Objeto (estructura más compleja)
var array = [3,4,5,8]           // COnjunto de datos en una variable</code></pre>
                  <p>Nos encontraremos que muchas veces no resulta tan sencillo saber que tipo de dato tiene una variable, o simplemente viene oculto porque el valor lo devuelve una función o alguna otra razón similar. Hay varias formas de saber que tipo de dato tiene una variable en Javascript:</p>
                  <h4>Utilizando typeof() </h4>
                  <p>Si tenemos dudas, podemos utilizar la función typeof, que nos devuelve el tipo de dato de la variable que le pasemos por parámetro. Veamos que nos devuelve typeof() sobre las variables del ejemplo anterior:</p>
                  <pre><code class="language-javascript">console.log(typeof s); // "string"
console.log(typeof n); // "number"
console.log(typeof b); // "boolean"
console.log(typeof u); // "undefined"</code></pre>
                  <blockquote>La función typeof() solo sirve para variables con tipos de datos básicos o primitivos.</blockquote>
                  <h4>Utilizando constructor.name</h4>
                  <p>Más adelante, nos encontraremos que en muchos casos, typeof() resulta insuficiente porque en tipos de datos más avanzados simplemente nos indica que son objetos. Con constructor.name podemos obtener el tipo de constructor que se utiliza, un concepto que veremos más adelante dentro del tema de clases. De momento, si lo necesitamos, podemos comprobarlo así:</p>
                  <pre><code>console.log(s.constructor.name); // String
console.log(n.constructor.name); // Number
console.log(b.constructor.name); // Boolean
console.log(u.constructor.name); // ERROR, sólo funciona con variables definidas</code></pre>
                  <blockquote>OJO: Sólo funciona en variables definidas (no undefined) y sólo en ECMAScript 6.						</blockquote>
                </div>
                <div class="section__theme section__theme--5">
                  <h2>Condicionales</h2>
                  <p>Cuando escribimos código Javascript, por defecto, el navegador leerá el script de forma secuencial, es decir, una línea detrás de otra, desde arriba hacia abajo. Por lo tanto, una acción que realicemos en la línea 5 nunca ocurrirá antes que una que aparece en la línea 3. Ya veremos que más adelante esto se complica, pero en principio partimos de esa base.</p>
                  <p>Al hacer un programa necesitaremos establecer condiciones o decisiones, donde buscamos que el navegador realice una acción A si se cumple una condición o una acción B si no se cumple. Este es el primer tipo de estructuras de control que encontraremos. Para ello existen varias estructuras de control:
                    <ul>
                      <li><strong>If:</strong>	Condición simple: Si ocurre algo, haz lo siguiente...</li>
                      <li><strong>If/else:</strong>	Condición con alternativa: Si ocurre algo, haz esto, sino, haz lo esto otro...</li>
                      <li><strong>?:</strong>	Operador ternario: Equivalente a If/else, método abreviado.</li>
                      <li><strong>Switch:</strong>	Estructura para casos específicos: Similar a varios If/else anidados.</li>
                    </ul>
                  </p>
                  <h4>Condicional If</h4>
                  <p>Quizás, el más conocido de estos mecanismos de estructura de control es el if (condicional). Con él podemos indicar en el programa que se tome un camino sólo si se cumple la condición que establezcamos:</p>
                  <pre><code class="language-javascript">var nota = 7;
console.log("He realizado mi examen.");
// Condición (si nota es mayor o igual a 5)
if (nota >= 5) {
	console.log("¡Estoy aprobado!");
}</code></pre>
                  <h4>Condicional If / else		</h4>
                  <p>Pero se puede dar el caso que queramos establecer una alternativa a una condición. Para eso utilizamos el if seguido de un else. Con esto podemos establecer una acción A si se cumple la condición, y una acción B si no se cumple.</p>
                  <p>Vamos a modificar el ejemplo anterior para mostrar también un mensaje cuando estamos suspendidos, pero en este caso, en lugar de mostrar el mensaje directamente con un console.log vamos a guardar ese texto en una nueva variable calificacion:</p>
                  <pre><code class="language-javascript">var nota = 7;
console.log("He realizado mi examen. Mi resultado es el siguiente:");
// Condición
if (nota < 5) {
	// Acción A (nota es menor que 5)
	calificacion = "suspendido";
} else {
	// Acción B: Cualquier otro caso a A (nota es mayor o igual que 5)
	calificacion = "aprobado";
}
console.log("Estoy", calificacion);</code></pre>
                  <h4>Operador ternario </h4>
                  <p>El operador ternario es una alternativa de condicional if/else de una forma mucho más corta y, en muchos casos, más legible. Vamos a reescribir el ejemplo anterior utilizando este operador:</p>
                  <pre><code class="language-javascript">var nota = 7;
console.log("He realizado mi examen. Mi resultado es el siguiente:");
// Operador ternario: (condición ? verdadero : falso)
var calificacion = nota < 5 ? "suspendido" : "aprobado";
console.log("Estoy", calificacion);</code></pre>
                  <p>Este ejemplo hace exactamente lo mismo que el ejemplo anterior. La idea del operador ternario es que podemos condensar mucho código y tener un if en una sola línea. Obviamente, es una opción que sólo se recomienda utilizar cuando son if muy pequeños.</p>
                  <h4>Condicional Switch </h4>
                  <p>La estructura de control switch permite definir casos específicos a realizar en el caso de que la variable expuesta como condición sea igual a los valores que se especifican a continuación mediante los case. No obstante, hay varias puntualizaciones que aclarar sobre este ejemplo:</p>
                  <pre><code class="language-javascript">var nota = 7;
console.log("He realizado mi examen. Mi resultado es el siguiente:");
// Nota: Este ejemplo NO es equivalente al ejemplo anterior (leer abajo)
switch (nota) {
	case 10:
		calificacion = "Insuficiente";
		break;
	case 9:
	case 8:
		calificacion = "Notable";
		break;
	case 7:
	case 6:
		calificacion = "Bien";
		break;
	case 5:
		calificacion = "Suficiente";
		break;
	case 4:
	case 3:
	case 2:
	case 1:
	case 0:
		calificacion = "Insuficiente";
		break;
	default:
		// Cualquier otro caso
		calificacion = "Nota errónea";
		break;
}
console.log("He obtenido un", calificacion);</code></pre>
                  <p>En primer lugar, el ejemplo anterior no es exactamente equivalente al anterior. Este ejemplo funcionaría si sólo permitimos notas que sean números enteros, es decir, números del 0 al 10, sin decimales. En el caso de que nota tuviera por ejemplo, el valor 7.5, mostraría Nota errónea.</p>
                  <blockquote>El ejemplo de los if múltiples si controla casos de números decimales porque establecemos comparaciones de rangos con mayor o menor, cosa que con el switch no se puede hacer. El switch está indicado para utilizar sólo con casos con valores concretos y específicos.</blockquote>
                  <p>En segundo lugar, observa que al final de cada caso es necesario indicar un break para salir del switch. En el caso que no sea haga, el programa saltará al siguiente caso, aunque no se cumpla la condición específica.</p>
                </div>
                <div class="section__theme section__theme--6">
                  <h2>Bucles e iteraciones</h2>
                  <p>Una de las principales ventajas de la programación es la posibilidad de crear bucles y repeticiones para tareas específicas, y que no tengamos que realizarlas varias veces de forma manual. Existen muchas formas de realizar bucles, vamos a ver los más basicos, similares en otros lenguajes de programación:</p>
                  <ul>
                    <li><strong>while:</strong>	Bucles simples.</li>
                    <li><strong>for:</strong>	Bucles clásicos por excelencia.</li>
                    <li><strong>do..while:</strong>	Bucles simples que se realizan siempre como mínimo una vez.</li>
                  </ul>
                  <p>Antes de comenzar a ver que tipos de bucles existen en Javascript, es necesario conocer algunos conceptos básicos de los bucles:</p>
                  <ul>
                    <li><strong>Condición:</strong> Al igual que en los if, en los bucles se va a evaluar una condición para saber si se debe repetir el bucle o finalizarlo. Generalmente, si la condición es verdadera, se repite. Si es falsa, se finaliza.</li>
                    <li><strong>Iteración:</strong> Cada repetición de un bucle se denomina iteración. Por ejemplo, si un bucle repite una acción 10 veces, se dice que tiene 10 iteraciones.</li>
                    <li><strong>Contador:</strong> Muchas veces, los bucles tienen una variable que se denomina contador, porque cuenta el número de repeticiones que ha hecho, para finalizar desde que llegue a un número concreto. Dicha variable hay que inicializarla (crearla y darle un valor) antes de comenzar el bucle.</li>
                    <li><strong>Incremento:</strong> Cada vez que terminemos un bucle se suele realizar el incremento (o decremento) de una variable, generalmente la denominada variable contador.</li>
                    <li><strong>Bucle infinito:</strong> Es lo que ocurre si en un bucle se nos olvida incrementar la variable contador o escribimos una condición que nunca se puede dar. El bucle se queda eternamente repitiéndose y el programa se queda «colgado».</li>
                  </ul>
                  <h4>Bucle while</h4>
                  <p>El bucle while es uno de los bucles más simples que podemos crear. Vamos a repasar el siguiente ejemplo y todas sus partes, para luego repasar que ocurre en cada iteración del bucle:</p>
                  <pre><code class="language-javascript">i = 0; // Inicialización de la variable contador
// Condición: Mientras la variable contador sea menor de 5
while (i < 5) {
	console.log("Valor de i:", i);
	i = i + 1; // Incrementamos el valor de i
}</code></pre>
                  <h4>Bucle for</h4>
                  <p>El bucle for es quizás uno de los más utilizados en el mundo de la programación. En Javascript se utiliza exactamente igual que en otros lenguajes como Java o C/C++. Veamos el ejemplo anterior utilizando un bucle for:</p>
                  <pre><code class="language-javascript">// for (inicialización; condición; incremento)
for (i = 0; i < 5; i++) {
	console.log("Valor de i:", i);
}</code></pre>
                  <p>Como vemos, la sintaxis de un bucle for es mucho más compacta y rápida de escribir que la de un bucle while. La primera vez puede parecer algo confusa, pero es mucho más práctica porque te obliga a escribir la inicialización, la condición y el incremento antes del propio bucle, y eso hace que no te olvides de estos tres puntos fundamentales.</p>
                  <blockquote>En programación es muy habitual empezar a contar desde cero. Mientras que en la vida real se contaría desde 1 hasta 10, en programación se contaría desde 0 hasta 9.</blockquote>
                  <h4>do..while</h4>
                  <p>La sentencia crea un bucle que ejecuta una sentencia especificada, hasta que la condición de comprobación se evalúa como falsa. La condición se evalúa después de ejecutar la sentencia, dando como resultado que la sentencia especificada se ejecute al menos una vez.</p>
                  <pre><code class="language-javascript">let result = '';
let i = 0;
do {
	i = i + 1;
	result = result + i;
} while (i < 5);
console.log(result);
// expected result: "12345"								</code></pre>
                </div>
                <div class="section__theme section__theme--7">
                  <h2>Funciones Básicas</h2>
                  <p>En programación, cuando nuestro código se va haciendo cada vez más grande, necesitaremos buscar una forma de organizarlo y prepararnos para reutilizarlo y no repetir innecesariamente las mismas tareas. Para ello, un primer recurso muy útil son las funciones.</p>
                  <p>Las funciones nos permiten agrupar líneas de código en tareas con un nombre, para que, posteriormente, podamos hacer referencia a ese nombre para realizar todo lo que se agrupe en dicha tarea. Para usar funciones hay que hacer 2 cosas:</p>
                  <ul>
                    <li><strong>Declarar la función:</strong> Preparar la función, darle un nombre y decirle las tareas que realizará.</li>
                    <li><strong>Ejecutar la función:</strong> «Llamar» a la función para que realice las tareas de su contenido.</li>
                  </ul>
                  <h4>Declaración</h4>
                  <p>En el siguiente ejemplo veremos la declaración de una función llamada saludar:</p>
                  <pre><code class="language-javascript">// Declaración de la función "saludar"
function saludar() {
	// Contenido de la función
	console.log("Hola, soy una función");
}</code></pre>
                  <h4>Ejecución		</h4>
                  <p>Veamos, ahora sí, el ejemplo completo con declaración y ejecución:</p>
                  <pre><code class="language-javascript">// Declaración de la función "saludar"
function saludar() {
	// Contenido de la función
	console.log("Hola, soy una función");
}
// Ejecución de la función
saludar();</code></pre>
                  <h4>¿Qué son los parámetros? </h4>
                  <p>Pero las funciones no sirven sólo para esto. Tienen mucha más flexibilidad de la que hemos visto hasta ahora. A las funciones se les pueden pasar parámetros, que no son más que variables que existirán sólo dentro de dicha función, con el valor pasado desde la ejecución.</p>
                  <p>Veamos el siguiente ejemplo, utilizando el parámetro <strong>hasta</strong>:</p>
                  <pre><code class="language-javascript">// Declaración
function tablaDelUno(hasta) {
	for (i = 0; i <= hasta; i++) console.log("1 x", i, "=", 1 * i);
}
// Ejecución
tablaDelUno(10);
tablaDelUno(5);	</code></pre>
                  <blockquote>La idea de las funciones es enfocarnos en el código de la declaración, y una vez lo tengamos funcionando, nos podemos olvidar de él porque está encapsulado dentro de la función. Simplemente tendremos que recordar el nombre de la función y los parámetros que hay que pasarle. Esto hace que sea mucho más fácil trabajar con el código.	</blockquote>
                  <h4>	Parámetros por defecto			</h4>
                  <p>Es posible que en algunos casos queramos que ciertos parámetros tengan un valor sin necesidad de escribirlos en la ejecución. Es lo que se llama un valor por defecto. 				</p>
                  <p>En nuestro ejemplo anterior, nos podría interesar que la tabla de multiplicar llegue siempre hasta el 10, ya que es el comportamiento por defecto. Si queremos que llegue hasta otro número, lo indicamos explicitamente, pero si lo omitimos, queremos que llegue hasta 10. Esto se haría de la siguiente forma: </p>
                  <pre><code class="language-javascript">function tablaMultiplicar(tabla, hasta = 10) {
	for (i = 0; i <= hasta; i++) console.log(tabla, "x", i, "=", tabla * i);
}
// Ejecución
tablaMultiplicar(2); // Esta tabla llegará hasta el número 10
tablaMultiplicar(2, 15); // Esta tabla llegará hasta el número 15</code></pre>
                  <blockquote>Hay que remarcar que esta característica se añade en ECMAScript 6, por lo que en navegadores sin soporte podría no funcionar correctamente.</blockquote>
                  <h4>Devolución de valores</h4>
                  <p>Hasta ahora hemos utilizado funciones simples que realizan acciones o tareas (en nuestro caso, mostrar por consola), pero habitualmente, lo que buscamos es que esa función realice una tarea y nos devuelva la información al exterior de la función, para así utilizarla o guardarla en una variable, que utilizaremos posteriormente para nuestros objetivos.</p>
                  <p>Para ello, se utiliza la palabra clave <strong>return</strong>, que suele colocarse al final de la función, ya que con dicha devolución terminamos la ejecución de la función (si existe código después, nunca será ejecutado).</p>
                  <p>Veamos un ejemplo con una operación muy sencilla, para verlo claramente:</p>
                  <pre><code class="language-javascript">// Declaración
function sumar(a, b) {
	return a + b; // Devolvemos la suma de a y b al exterior de la función
	console.log("Ya he realizado la suma."); // Este código nunca se ejecutará
}
// Ejecución
var resultado = sumar(5, 5); // Se guarda 10 en la variable resultado	</code></pre>
                  <p>Como podemos ver, esto nos permite crear funciones más modulares y reutilizables que podremos utilizar en multitud de casos, ya que la información se puede enviar al exterior de la función y utilizarla junto a otras funciones o para otros objetivos.		</p>
                </div>
                <div class="section__theme section__theme--8">
                  <h2>Objetos basicos</h2>
                  <p>Uno de los aspectos más importantes del lenguaje Javascript es el concepto de objeto, puesto que prácticamente todo lo que utilizamos en Javascript, son objetos. Sin embargo, tiene ligeras diferencias con los objetos de otros lenguajes de programación, así que vamos a comenzar con una explicación sencilla y más adelante ampliaremos este tema en profundidad.</p>
                  <p>En Javascript, existe un tipo de dato llamado objeto. No es más que una variable especial que puede contener más variables en su interior. De esta forma, tenemos la posibilidad de organizar múltiples variables de la misma temática dentro de un objeto. Veamos algunos ejemplos:</p>
                  <h4>Declaración de un objeto</h4>
                  <p>Los literales de los objetos en Javascript son las llaves {}. Este ejemplo es equivalente al anterior, pero es más corto, rápido y cómodo, por lo que se aconseja declararlos así:</p>
                  <pre><code class="language-javascript">const objeto = {}; // Esto es un objeto vacío</code></pre>
                  <p>Pero hasta ahora, solo hemos creado un objeto vacío. Vamos a crear un nuevo objeto, que contenga variables con información en su interior:</p>
                  <pre><code class="language-javascript">// Declaración del objeto
const player = {
	name: "Manz",
	life: 99,
	strength: 10,
};										</code></pre>
                  <p>Estas variables dentro de los objetos se suelen denominar propiedades. Como se puede ver, un objeto en Javascript nos permite encapsular en su interior información relacionada, para posteriormente poder acceder a ella de forma más sencilla e intuitiva.</p>
                  <h4>Acceso a sus propiedades</h4>
                  <p>Una vez tengamos un objeto, podemos acceder a sus propiedades de dos formas diferentes: a través de la notación con puntos o a través de la notación con corchetes.</p>
                  <pre><code class="language-javascript">// Notación con puntos
console.log(player.name); // Muestra "Manz"
console.log(player.life); // Muestra 99
// Notación con corchetes
console.log(player["name"]); // Muestra "Manz"
console.log(player["life"]); // Muestra 99	</code></pre>
                  <h4>Añadir propiedades				</h4>
                  <p>También podemos añadir propiedades al objeto después de haberlo creado, aunque la sintaxis cambia ligeramente. Veamos un ejemplo equivalente al anterior:</p>
                  <pre><code class="language-javascript">// Declaración del objeto
const player = {};
// Añadimos mediante notación con puntos
player.name = "Manz";
player.life = 99;
player.strength = 10;
// Añadimos mediante notación con corchetes
player["name"] = "Manz";
player["life"] = 99;
player["strength"] = 10;</code></pre>
                </div>
                <div class="section__theme section__theme--9">
                  <h2>Variables numéricas (NUMBER)</h2>
                  <p>En Javascript crear variables numéricas es muy sencillo, pero hay que conocer bien como trabajar con ellas y los diferentes métodos de los que dispone.</p>
                  <h4>¿Qué es una variable numérica?</h4>
                  <p>En Javascript, los números son uno de los tipos de datos básicos (tipos primitivos) que para crearlos, simplemente basta con escribirlos. No obstante, en Javascript todo son objetos, como veremos más adelante, y también se pueden declarar como si fueran un objeto:</p>
                  <ul>
                    <li><strong>new Number(n):</strong> Crea un objeto numérico a partir del número n pasado por parámetro.</li>
                    <li><strong>n:</strong> Simplemente, el número en cuestión. Notación preferida.</li>
                  </ul>
                  <p>Sin embargo, aunque existan varias formas de declararlos, no se suele utilizar la notación new con objetos primitivos ya que es bastante más tedioso y complicado que utilizar la notación de literales:</p>
                  <pre><code class="language-javascript">// Literales
const n1 = 4;
const n2 = 15.8;
// Objetos
const n1 = new Number(4);
const n2 = new Number(15.8);</code></pre>
                  <p>Cualquier parámetro pasado al new Number() que no sea un número, dará como resultado un valor NaN (ver más adelante).</p>
                  <h4>Constantes numéricas </h4>
                  <p>Existe una serie de constantes definidas en relación a las variables numéricas. La mayoría de ellas establecen límites máximos y mínimos, veamos su significado:</p>
                  <ul>
                    <li><strong>Number.POSITIVE_INFINITY:</strong> Infinity (Infinito positivo: +∞)</li>
                    <li><strong>Number.NEGATIVE_INFINITY:</strong> -Infinity (Infinito negativo: -∞)</li>
                    <li><strong>Number.MAX_VALUE:</strong> 1.7976931348623157e+308 (Valor más grande)</li>
                    <li><strong>Number.MIN_VALUE:</strong> 5e-324 (Valor más pequeño)</li>
                    <li><strong>Number.MAX_SAFE_INTEGER: </strong> 9007199254740991 (Valor seguro más grande)</li>
                    <li><strong>Number.MIN_SAFE_INTEGER:</strong> -9007199254740991 (Valor seguro más pequeño)</li>
                    <li><strong>Number.EPSILON: </strong> 2-52 (Número muy pequeño: ε)</li>
                    <li><strong>Number.NaN.</strong> NaN (Not A Number)</li>
                  </ul>
                  <p>La diferencia entre Number.MAX_VALUE y Number.MAX_SAFE_INTEGER es que, el primero es el valor máximo que es posible representar en Javascript. Por otro lado, el segundo es el valor máximo para realizar cálculos con seguridad en Javascript.</p>
                  <h4>Comprobaciones numéricas </h4>
                  <p>En Javascript tenemos varias funciones para conocer la naturaleza de una variable numérica (número finito, número entero, número seguro o si no es representable como un número). Las podemos ver a continuación en la siguiente tabla:</p>
                  <ul>
                    <li><strong>Number.isFinite(n):</strong> Comprueba si n es un número finito.</li>
                    <li><strong>Number.isInteger(n):</strong> Comprueba si n es un número entero.</li>
                    <li><strong>Number.isSafeInteger(n):</strong> Comprueba si n es un número seguro.</li>
                    <li><strong>Number.isNaN(n):</strong> Comprueba si n no es un número.</li>
                  </ul>
                  <p>Ten en cuenta que estas funciones devuelven un booleano (valor de verdadero o falso), lo que lo hace ideales para usarlas como condiciones en bucles o condicionales. A continuación veamos dos ejemplos para cada una de estas funciones:</p>
                  <pre><code class="language-javascript">// ¿Número finito?
Number.isFinite(42); // true
Number.isFinite(Infinity); // false, es infinito
// ¿Número entero?
Number.isInteger(5); // true
Number.isInteger(4.6); // false, es decimal
// ¿Número seguro?
Number.isSafeInteger(1e15); // true
Number.isSafeInteger(1e16); // false, es un valor no seguro
// ¿No es un número?
Number.isNaN(NaN); // true
Number.isNaN(5); // false, es un número</code></pre>
                  <p>Recuerda no hacer comprobaciones directas con NaN, sino utilizar la función Number.isNaN().</p>
                  <h4>Conversión numérica</h4>
                  <p>En muchos casos tendremos variables de texto que nos interesa convertir a número, para realizar operaciones posteriormente con ellas. Para ello, lo ideal es utilizar las funciones de parseo numérico, parseInt() y parseFloat(). Veamos cuales son y cómo se pueden utilizar:</p>
                  <ul>
                    <li><strong>Number.parseInt(s):</strong> Convierte una cadena de texto s en un número entero.</li>
                    <li><strong>Number.parseInt(s, radix):</strong> Idem al anterior, pero desde una base radix.</li>
                    <li><strong>Number.parseFloat(s):</strong> Convierte una cadena de texto s en un número decimal.</li>
                    <li><strong> Number.parseFloat(s, radix):</strong> Idem al anterior, pero desde una base radix.</li>
                  </ul>
                  <p>Para ilustrar esto, veamos un ejemplo con parseInt() cuando solo le pasamos un parámetro (un texto) que queremos convertir a número:</p>
                  <pre><code class="language-javascript">Number.parseInt("42"); // 42
Number.parseInt("42€"); // 42
Number.parseInt("Núm. 42"); // NaN
Number.parseInt("A"); // NaN</code></pre>
                  <p>Nota que la función parseInt() funciona perfectamente para variables de texto que contienen números o que empiezan por números. Esto es muy útil para eliminar unidades de variables de texto. Sin embargo, si la variable de texto comienza por un valor que no es numérico, parseInt() devolverá un NaN.</p>
                  <blockquote>	Si lo que queremos es quedarnos con el número que aparece más adelante en la variable de texto, habrá que manipular ese texto con alguna de las funciones que veremos en el apartado de variables de texto.	</blockquote>
                  <p>Veamos ahora que ocurre si utilizamos parseInt() con dos parámetros, donde el primero es el texto con el número y el segundo es la base numérica del número:</p>
                  <pre><code class="language-javascript">Number.parseInt("11101", 2); // 29 en binario
Number.parseInt("31", 8); // 25 en octal
Number.parseInt("FF", 16); // 255 en hexadecimal</code></pre>
                  <p>Esta modalidad de parseInt() se suele utilizar cuando queremos pasar a base decimal un número que se encuentra en otra base (binaria, octal, hexadecimal...).</p>
                  <blockquote>Al igual que con parseInt() tenemos otra función llamada parseFloat(). Funciona exactamente igual a la primera, sólo que la primera está específicamente diseñada para utilizar con números enteros y la segunda para números decimales. Si utilizamos parseInt() con un número decimal, nos quedaremos sólo con la parte entera, mientras que parseFloat() la conservará.</blockquote>
                  <h4>Representación numérica</h4>
                  <p>Por último, en el caso de querer cambiar el tipo de representación numérica, podemos utilizar las siguientes funciones para alternar entre exponencial y punto fijo:</p>
                  <ul>
                    <li><strong>.toExponential(n):</strong> Convierte el número a notación exponencial con n decimales.</li>
                    <li><strong>.toFixed(n):</strong> Convierte el número a notación de punto fijo con n decimales.</li>
                    <li><strong> .toPrecision(p):</strong> Utiliza p dígitos de precisión en el número.</li>
                  </ul>
                  <p>Observemos el siguiente ejemplo aplicando las funciones anteriores al número decimal 1.5:</p>
                  <pre><code class="language-javascript">(1.5).toExponential(2); // "1.50e+0" en exponencial
(1.5).toFixed(2); // "1.50" en punto fijo
(1.5).toPrecision(1); // "2"</code></pre>
                </div>
                <div class="section__theme section__theme--10">
                  <h2>Operaciones matemáticas (Math)</h2>
                  <p>Cuando trabajamos con Javascript, es posible realizar gran cantidad de operaciones matemáticas de forma nativa, sin necesidad de librerías externas. Para ello, haremos uso del objeto Math, un objeto interno de Javascript que tiene incorporadas ciertas constantes y métodos (funciones) para trabajar matemáticamente.</p>
                  <h4>Constantes de Math</h4>
                  <p>El objeto Math de Javascript incorpora varias constantes que podemos necesitar en algunas operaciones matemáticas. Veamos su significado y valor aproximado:</p>
                  <ul>
                    <li><strong>Math.E:</strong> Número de Euler = 2.718281828459045</li>
                    <li><strong>Math.LN2:</strong> Logaritmo natural en base 2 = 0.6931471805599453</li>
                    <li><strong>Math.LN10:</strong> Logaritmo decimal = 2.302585092994046</li>
                    <li><strong>Math.LOG2E:</strong> Logaritmo base 2 de E = 1.4426950408889634</li>
                    <li><strong>Math.LOG10E: </strong> Logaritmo base 10 de E = 0.4342944819032518</li>
                    <li><strong>Math.PI:</strong> Número PI o Π = 3.141592653589793</li>
                    <li><strong>Math.SQRT1_2: </strong> Raíz cuadrada de 1/2 = 0.7071067811865476</li>
                    <li><strong>Math.SQRT2:</strong> Raíz cuadrada de 2 = 1.4142135623730951</li>
                  </ul>
                  <p>Además de estas constantes, el objeto Math también nos proporciona gran cantidad de métodos o funciones para trabajar con números. Vamos a analizarlos.</p>
                  <h4>Métodos matemáticos</h4>
                  <p>Los siguientes métodos matemáticos están disponibles en Javascript a través del objeto Math. Observa que algunos de ellos sólo están disponibles en ECMAScript 6:</p>
                  <ul>
                    <li><strong>Math.abs(x):</strong> Devuelve el valor absoluto de x.</li>
                    <li><strong>Math.sign(x) :</strong> Devuelve el signo del número: 1 positivo, -1 negativo</li>
                    <li><strong>Math.exp(x):</strong> Exponenciación. Devuelve el número e elevado a x.</li>
                    <li><strong>Math.expm1(x) :</strong> Equivalente a Math.exp(x) - 1.</li>
                    <li><strong>Math.max(a, b, c...): </strong> 	Devuelve el número más grande de los indicados por parámetro.</li>
                    <li><strong>Math.min(a, b, c...):</strong> 	Devuelve el número más pequeño de los indicados por parámetro.</li>
                    <li><strong>Math.pow(base, exp): </strong> Potenciación. Devuelve el número base elevado a exp.</li>
                    <li><strong>Math.sqrt(x):</strong> Devuelve la raíz cuadrada de x.</li>
                    <li><strong>Math.cbrt(x):</strong> Devuelve la raíz cúbica de x.</li>
                    <li><strong>Math.imul(a, b):</strong> Equivalente a a * b, pero a nivel de bits.</li>
                    <li><strong>Math.clz32(x):</strong> Devuelve el número de ceros a la izquierda de x en binario (32 bits).</li>
                  </ul>
                  <p>Veamos algunos ejemplos aplicados a las mencionadas funciones anteriormente:</p>
                  <pre><code class="language-javascript">Math.abs(-5); // 5
Math.sign(-5); // -1
Math.exp(1); // e, o sea, 2.718281828459045
Math.expm1(1); // 1.718281828459045
Math.max(1, 40, 5, 15); // 40
Math.min(5, 10, -2, 0); // -2
Math.pow(2, 10); // 1024
Math.sqrt(2); // 1.4142135623730951
Math.cbrt(2); // 1.2599210498948732
Math.imul(0xffffffff, 7); // -7
// Ejemplo de clz32 (count leading zeros)
const x = 1;
"0".repeat(Math.clz32(x)) + x.toString(2);
// Devuelve "00000000000000000000000000000001"							</code></pre>
                  <p>Existe uno más, Math.random() que merece una explicación más detallada, por lo que lo explicamos en el apartado siguiente.</p>
                  <h4>Método Math.random()</h4>
                  <p>Uno de los métodos más útiles e interesantes del objeto Math es Math.random().</p>
                  <ul>
                    <li><strong>Math.random():</strong> Devuelve un número al azar entre 0 y 1 con 16 decimales.</li>
                  </ul>
                  <p>Este método nos da un número al azar entre los valores 0 y 1, con 16 decimales. Normalmente, cuando queremos trabajar con números aleatorios, lo que buscamos es obtener un número entero al azar entre a y b. Para ello, se suele hacer lo siguiente:</p>
                  <pre><code class="language-javascript">// Obtenemos un número al azar entre [0, 1) con 16 decimales
let x = Math.random();
// Multiplicamos dicho número por el valor máximo que buscamos (5)
x = x * 5;
// Redondeamos inferiormente, quedándonos sólo con la parte entera
x = Math.floor(x);</code></pre>
                  <p>Este ejemplo nos dará en x un valor al azar entre 0 y 5 (5 no incluido). Lo hemos realizado por pasos para entenderlo mejor, pero podemos realizarlo directamente como se ve en el siguiente ejemplo:</p>
                  <pre><code class="language-javascript">// Número al azar entre 0 y 5 (no incluido)
const x = Math.floor(Math.random() * 5);
// Equivalente al anterior
const x = ~~(Math.random() * 5);</code></pre>
                  <p>Como se puede ver en el segundo ejemplo anterior, utilizamos el operador a nivel de bits ~~ (doble negación) como reemplazo rápido de Math.floor(), una función que realiza un redondeo inferior, y que veremos al final de este tema.</p>
                  <blockquote>Si lo deseas, puedes utilizar librerías específicas para generar números aleatorios como random.js o chance.js, esta última permitiendo incluso generar otros tipos de datos aleatorios como textos, GUIDs o colores hexadecimales.</blockquote>
                  <h4>Métodos de redondeo </h4>
                  <p>Como hemos visto anteriormente, es muy común necesitar métodos para redondear números y reducir el número de decimales o aproximar a una cifra concreta. Para ello, de forma nativa, Javascript proporciona los siguientes métodos de redondeo:</p>
                  <ul>
                    <li><strong>Math.round(x):</strong> Devuelve el redondeo de x (el entero más cercano)</li>
                    <li><strong>Math.ceil(x) :</strong> Devuelve el redondeo superior de x. (el entero más alto)</li>
                    <li><strong>Math.floor(x):</strong> Devuelve el redondeo inferior de x. (el entero más bajo)</li>
                    <li><strong>Math.fround(x)  :</strong> Devuelve el redondeo de x (flotante con precisión simple)</li>
                    <li><strong>Math.trunc(x) : </strong> Trunca el número x (devuelve sólo la parte entera)</li>
                  </ul>
                  <p>Veamos las diferencias de utilizar los diferentes métodos anteriores para redondear un número decimal y los resultados obtenidos:</p>
                  <pre><code class="language-javascript">// Redondeo natural, el más cercano
Math.round(3.75); // 4
Math.round(3.25); // 3
// Redondeo superior (el más alto)
Math.ceil(3.75); // 4
Math.ceil(3.25); // 4
// Redondeo inferior (el más bajo)
Math.floor(3.75); // 3
Math.floor(3.25); // 3
// Redondeo con precisión
Math.round(3.123456789); // 3
Math.fround(3.123456789); // 3.1234567165374756
// Truncado (sólo parte entera)
Math.trunc(3.75); // 3
Math.round(-3.75); // -4
Math.trunc(-3.75); // -3</code></pre>
                  <h4>Otras librerías matemáticas </h4>
                  <p>Si de forma nativa no encuentras una forma sencilla de resolver el problema matemático que tienes entre manos, no olvides que existen una serie de librerías de terceros que pueden hacernos la vida más fácil a la hora de trabajar con otros valores matemáticos.</p>
                  <p>A continuación, detallamos algunas de ellas:</p>
                  <ul>
                    <li><strong>Math.js:</strong> Librería matemática de propósito general.</li>
                    <li><strong>Fraction.js :</strong> Librería matemática para trabajar con fracciones.</li>
                    <li><strong>Polynomial.js:</strong> Librería matemática para trabajar con polinomios.</li>
                    <li><strong>Complex.js :</strong> Librería matemática para trabajar con números complejos.</li>
                    <li><strong>Angles.js : </strong> Librería matemática para trabajar con ángulos.</li>
                    <li><strong>BitSet.js : </strong> Librería matemática para trabajar con vectores de bits.</li>
                  </ul>
                  <p>Habrás comprobado que, al contrario que muchos otros objetos de Javascript, en estas ocasiones hemos indicado explícitamente el objeto, por ejemplo Math.round(numero), en lugar de hacerlo sobre la variable: numero.round(). Esto ocurre porque Math es un objeto con métodos y constantes estáticas, algo que veremos en profundidad en futuros temas.</p>
                </div>
                <div class="section__theme section__theme--11">
                  <h2>Variables de texto (String)</h2>
                  <p>En Javascript y en el mundo del desarrollo web, una de las tareas que más solemos hacer es manejar cadenas de texto y realizando tareas con ellas. Por lo tanto, tenemos que familiarizarnos con el tipo de dato <span class="span_tag span_string">STRING</span>.</p>
                  <h4>¿Qué es un string? </h4>
                  <p>En programación, cuando hablamos de una varible que posee información de texto, decimos que su tipo de dato es <span class="span_tag span_string">STRING</span>. En Javascript, es muy sencillo crear una variable de texto, hay dos formas de hacerlo:</p>
                  <ul>
                    <li><strong>new String(s)</strong> Crea un objeto de texto a partir del texto s pasado por parámetro.</li>
                    <li><strong>'s'</strong> Simplemente, el texto entre comillas. Notación preferida.</li>
                  </ul>
                  <p>Los <span class="span_tag span_string">STRING</span> son tipos de datos primitivos, y como tal, es más sencillo utilizar los literales que la notación con `new`. Para englobar los textos, se pueden utilizar comillas simples `'`, comillas dobles `"` o backticks ` (ver más adelante).</p>
                  <blockquote>Aunque es posible utilizar comillas simples o comillas dobles en los <span class="span_tag span_string">STRING</span>, se recomienda decantarse por uno de los dos estilos y no mezclarlos. Muchas empresas o equipos de desarrollo tienen guías de estilos para delimitar cuál utilizar.</blockquote>
                  <p>A continuación, un ejemplo de declaración de variables de texto en Javascript:</p>
                  <pre><code class="language-javascript">// Literales
const texto1 = "¡Hola a todos!";
const texto2 = "Otro mensaje de texto";
// Objeto
const texto1 = new String("¡Hola a todos!");
const texto2 = new String("Otro mensaje de texto");</code></pre>
                  <p>A diferencia de otros lenguajes de programación, que separan el tipo de dato <span class="span_tag span_string">STRING</span> (cadena de texto) del tipo de dato char (un solo carácter), Javascript los mantiene a ambos dentro del tipo de dato <span class="span_tag span_string">STRING</span>, por lo que una variable, aunque sólo contenga un carácter, sigue siendo un <span class="span_tag span_string">STRING</span>.</p>
                  <h4>Propiedades </h4>
                  <p>Al crear una variable con contenido de texto, o sea un <span class="span_tag span_string">STRING</span>, automáticamente, esa variable pasa a tener a su disposición todas las propiedades y métodos disponibles para este tipo de dato, por lo que podemos utilizarlos en nuestro código como iremos viendo a continuación.</p>
                  <ul>
                    <li><strong>.length</strong> Devuelve el número de carácteres de la variable de tipo string en cuestión.</li>
                  </ul>
                  <p>En el caso de los strings, solo tenemos una propiedad, .length, que devuelve el tamaño de la variable de texto en cuestión. Nótese en los siguientes ejemplos que se han utilizado <span class="span_tag span_string">STRING</span> directamente, sin necesidad de guardarlos en una variable antes:</p>
                  <pre><code class="language-javascript">"Hola".length; // 4
"Adiós".length; // 5
"".length; // 0
"¡Yeah!".length; // 6</code></pre>
                  <p>Pero las características más interesantes de los strings se encuentran en los métodos de dicho tipo de dato. Ten en cuenta que, en las variables de texto, los métodos se ejecutan sobre el propio texto del <span class="span_tag span_string">STRING</span>, devolviendo información modificada a partir de este. Vamos a dar un repaso a los métodos que existen.</p>
                  <h4>Métodos de posiciones</h4>
                  <p>En primer lugar existen varios métodos que permiten darnos información sobre la posición o ubicación que ocupa un determinado carácter o texto. Esta posición también suele denominarse índice. Veamos detalladamente dicho métodos:</p>
                  <ul>
                    <li><strong>.charAt(pos):</strong> Devuelve el carácter en la posición pos de la variable.</li>
                    <li><strong>.concat(str1, str2...):</strong> Devuelve el texto de la variable unido a str1, a str2...</li>
                    <li><strong>.indexOf(str):</strong> Devuelve la primera posición del texto str.</li>
                    <li><strong>.indexOf(str, from):</strong> Idem al anterior, partiendo desde la posición from.</li>
                    <li><strong>.lastIndexOf(str, from): </strong> Idem al anterior, pero devuelve la última posición.</li>
                  </ul>
                  <p>El método .charAt(pos) nos permite comprobar que carácter se encuentra en la posición pos del texto. Este método devolverá un <span class="span_tag span_string">STRING</span> con dicho carácter. En caso de pasarle una posición que no existe o imposible (negativa), simplemente nos devolverá un <span class="span_tag span_string">STRING</span> vacío. El valor por defecto de pos es 0.</p>
                  <p>No obstante, es preferible utilizar el operador [] para obtener el carácter que ocupa una posición, ya que es más corto y rápido de utilizar y mucho más claro. La diferencia respecto a charAt() es que el operador [] devuelve  si en esa posición no existe ningún carácter.</p>
                  <pre><code class="language-javascript">"Manz".charAt(0); // 'M'
"Manz".charAt(1); // 'a'
"Manz".charAt(10); // ''
"Manz"[0]; // 'M'
"Manz"[1]; // 'a'
"Manz"[10]; // undefined</code></pre>
                  <P>El método .concat(str1, str2...) permite concatenar (unir) los textos pasados por parámetros al de la propia variable. Al igual que el método anterior, es preferible utilizar el operador +, ya que es mucho más rápido y legible. Mucho cuidado con utilizar el operador +, ya que depende de los tipos de datos con los que se usen puede producir un efecto diferente. El operador + usado con <span class="span_tag span_string">STRING</span> realiza concatenaciones, mientras que usado con <span class="span_tag span_number">NUMBER</span> realiza sumas.</P>
                  <pre><code class="language-javascript">"Manz".concat("i", "to"); // 'Manzito'
"Manz" + "i" + "to"; // 'Manzito'
"Manz" + 4 + 5; // 'Manz45'
10 + 5 + 4 + 5; // 24</code></pre>
                  <p>Por último, nos queda el método indexOf(str, from), que es la función opuesta a charAt(). La función indexOf(str) buscará el subtexto str en nuestra variable y nos devolverá un <span class="span_tag span_number">NUMBER</span> con la posición de la primera aparición de dicho subtexto. En caso de no encontrarlo, devolverá -1. El parámetro from es opcional, y es la posición en la que empezará a buscar, que por defecto (si no se suministra) es 0.</p>
                  <pre><code class="language-javascript">"LenguajeJS, página de Javascript".indexOf("n"); // 2
"LenguajeJS, página de Javascript".indexOf("n", 3); // 16
"LenguajeJS, página de Javascript".indexOf("n", 17); // -1
"LenguajeJS, página de Javascript".lastIndexOf("n"); // 16
"LenguajeJS, página de Javascript".lastIndexOf("n", 3); // 2</code></pre>
                  <p>El método lastIndexOf(str, from) funciona exactamente igual que el anterior, sólo que realiza la búsqueda de la última aparición en lugar de la primera aparición.</p>
                  <h4>Métodos para transformar</h4>
                  <p>En Javascript podemos utilizar algunos métodos para modificar un <span class="span_tag span_string">STRING</span> realizando alguna operación de transformación. En esta tabla tenemos dichos métodos:</p>
                  <ul>
                    <li><strong>.repeat(n:)</strong> Devuelve el texto de la variable repetido n veces.</li>
                    <li><strong>.toLowerCase():</strong> Devuelve el texto de la variable en minúsculas.</li>
                    <li><strong>.toUpperCase():</strong> Devuelve el texto de la variable en mayúsculas.</li>
                    <li><strong>.trim():</strong> Devuelve el texto sin espacios a la izquierda y derecha.</li>
                    <li><strong>.trimStart(): </strong> Devuelve el texto sin espacios a la izquierda.</li>
                    <li><strong>.trimEnd():</strong> Devuelve el texto sin espacios a la derecha.</li>
                    <li><strong>.replace(str|regex, newstr):</strong> 	Reemplaza la primera aparición del texto str por newstr.</li>
                    <li><strong>.replaceAll(str|regex, newstr):</strong> Reemplaza todas las apariciones del texto str por newstr.</li>
                    <li><strong>.replace(str|regex, func): </strong> Idem a .replace(), pero reemplazando por la devolución de func.</li>
                    <li><strong>.substr(ini, len): </strong> Devuelve el subtexto desde la posición ini hasta ini+len.</li>
                    <li><strong>.substring(ini, end): </strong> Devuelve el subtexto desde la posición ini hasta end.</li>
                    <li><strong>.slice(ini, end): </strong> Idem a .substr() con leves diferencias.</li>
                    <li><strong>.split(sep|regex, limit): </strong> Separa el texto usando sep como separador, en limit fragmentos.</li>
                    <li><strong>.padStart(len, str) : </strong> Rellena el principio de la cadena con str hasta llegar al tamaño len.</li>
                    <li><strong>.padEnd(len, str) : </strong> Rellena el final de la cadena con str hasta llegar al tamaño len.</li>
                  </ul>
                  <P>El método repeat(n) devuelve como <span class="span_tag span_string">STRING</span> el texto repetido n veces. Por otro lado, los métodos toLowerCase() y toUpperCase() devuelven el texto convertido todo a minúsculas o todo a mayúsculas respectivamente:</P>
                  <pre><code class="language-javascript">"Na".repeat(5); // 'NaNaNaNaNa'
"MANZ".toLowerCase(); // 'manz'
"manz".toUpperCase(); // 'MANZ'
"    Hola  ".trim(); // 'Hola'</code></pre>
                  <P>Por último, el método trim(), informalmente traducido como «afeitar» se encarga de devolver el texto eliminando los espacios sobrantes que hay a la izquierda o a la derecha del texto (y sólo esos, nunca los que hay entre palabras). De la misma forma, trimStart() y trimEnd() realizan la misma tarea sólo a la izquierda y sólo a la derecha respectivamente.</P>
                  <h4>Reemplazar textos</h4>
                  <p>Uno de los métodos más interesantes de transformación de <span class="span_tag span_string">STRING</span> es el replace(str, newstr). Su funcionalidad más básica, como se ve en el primer ejemplo, se trata de devolver el texto en cuestión, reemplazando el texto str por newstr (¡y solo la primera aparición!):</p>
                  <pre><code class="language-javascript">"Amigo".replace("A", "Ene"); // 'Enemigo'
"Dispara".replace("a", "i"); // 'Dispira' (sólo reemplaza la primera aparición)
"Dispara".replace(/a/g, "i"); // 'Dispiri' (reemplaza todas las ocurrencias)</code></pre>
                  <p>Si lo que nos interesa es reemplazar todas las apariciones, tendremos que hacer uso de las expresiones regulares, que veremos en temas posteriores a este. A grandes rasgos, en el tercer ejemplo anterior, en lugar de indicar el string 'a' indicamos la expresión regular /a/g que buscará todas las apariciones de a de forma global (todas las ocurrencias).</p>
                  <blockquote>Desde ECMAScript {.es2021} es posible utilizar replaceAll() para reemplazar todas las ocurrencias de un texto o de una expresión regular. Funciona exactamente igual que replace(), sólo que reemplaza todas las ocurrencias en vez de solamente la primera.</blockquote>
                  <p>Además, el método replace() nos permite indicar, como segundo parámetro una <strong>FUNCTION</strong> en lugar de un <span class="span_tag span_string">STRING</span>, permitiendo utilizar dicha función para realizar un proceso más complejo al reemplazar, en lugar de simplemente reemplazar por un <span class="span_tag span_string">STRING</span>. Sin embargo, para aprender a utilizar esta funcionalidad, antes tendremos que aprender los callbacks, que veremos también más adelante.</p>
                  <h4>Extraer subtextos</h4>
                  <p>Otras de las operaciones fundamentales de los <span class="span_tag span_string">STRING</span> es la posibilidad de extraer pequeños fragmentos de texto de textos más grandes. Para ello tenemos dos aproximaciones para realizarlo: con el método substr() o con el método substring().</p>
                  <p>En el primer caso, el método substr(ini, len) nos solicita dos parámetros, ini, que es la posición inicial del subtexto, y len, que es el tamaño o longitud que tendrá el texto. De esta forma, substr(2, 4) extrae el fragmento de texto desde la posición 2 y desde esa posición 4 posiciones más. En el caso de omitirse el parámetro len, se devuelve el subtexto hasta el final del texto original:</p>
                  <pre><code class="language-javascript">"Submarino".substr(3); // 'marino' (desde el 3 en adelante)
"Submarino".substr(3, 1); // 'm'      (desde el 3, hasta el 3+1)
"Submarino".substring(3); // 'marino' (desde el 3 en adelante)
"Submarino".substring(3, 6); // 'mar'    (desde el 3, hasta el 6)</code></pre>
                  <p>Por otro lado, el método substring(ini, end) extrae el fragmento de texto desde la posición ini hasta la posición end. De igual forma al anterior, si se omite el parámetro end, el subtexto abarcará hasta el final del texto original.</p>
                  <h4>Crear Arrays a partir de textos</h4>
                  <p>Otro método muy útil es split(sep), un método que permite dividir un <span class="span_tag span_string">STRING</span> por el substring sep como separador, devolviendo un array con cada una de las partes divididas. Es muy útil para crear arrays, o dividir en diferentes secciones textos que tienen separadores repetidos como podrían ser comas, puntos o pipes:</p>
                  <pre><code class="language-javascript">"1.2.3.4.5".split("."); // ['1', '2', '3', '4', '5'] (5 elementos)
"Hola a todos".split(" "); // ['Hola', 'a', 'todos'] (3 elementos)
"Código".split(""); // ['C', 'ó', 'd', 'i', 'g', 'o'] (6 elementos)</code></pre>
                  <p>En el último ejemplo, el separador es una cadena vacía, es decir, «ningún carácter». Si le indicamos a split() que separe por «ningún carácter», lo que hace es hacer una división en su unidad mínima, carácter por carácter.</p>
                  <blockquote>En el tema de los arrays veremos un método llamado join() que es justo el opuesto de split(). Si split separa un string en varios y los mete en un array, join une varios elementos de un array añadiéndole un separador y lo convierte en string.</blockquote>
                  <h4>Relleno de cadenas </h4>
                  <p>Otra transformación interesante con los <span class="span_tag span_string">STRING</span> es la resultante de utilizar métodos como padStart(len, str) o padEnd(len, str). Ambos métodos toman dos parámetros: len la longitud deseada del <span class="span_tag span_string">STRING</span> resultante y str el carácter a utilizar como relleno.</p>
                  <p>El objetivo de ambas funciones es devolver un nuevo <span class="span_tag span_string">STRING</span> con la información original existente, pero ampliando su tamaño a len y rellenando el resto con str, al principio si se usa padStart() o al final si se usa padEnd():</p>
                  <pre><code class="language-javascript">"5".padStart(6, "0"); // '000005'
"A".padEnd(5, "·"); // 'A····'</code></pre>
                  <blockquote>Estos métodos resultan especialmente interesantes para formatear horas, como por ejemplo en el caso que queremos que las cifras menores a 10 aparezcan en formato 00 en lugar de 0.</blockquote>
                  <h4>Métodos Unicode</h4>
                  <p>Unicode es el nombre por el que se conoce al sistema moderno de codificación de carácteres que se usa en informática. A grandes rasgos, cada carácter como podría ser la A, la B o cualquier otro, tiene su representación Unicode, que se basa en un código o code point.</p>
                  <p>Por ejemplo, el carácter A corresponde al código Unicode U+0041. Este 0041 realmente está en hexadecimal, por lo que 0x0041 en decimal sería igual a 65. Existen muchísimos códigos, ya que cualquier carácter existente, tiene su propio código Unicode. En Javascript, tenemos dos métodos interesantes relacionado con este tema:</p>
                  <ul>
                    <li><strong>String.fromCharCode(num):</strong> Devuelve el carácter del valor unicode indicado en num.</li>
                    <li><strong>.charCodeAt(pos):</strong> Devuelve el valor unicode del carácter de la posición pos del texto.</li>
                  </ul>
                  <p>El primero de ellos es un método estático, por lo que hay que escribir directamente String.fromCharCode() y no utilizarlo desde una variable. Para usar este método, le pasamos un num por parámetro, que indicará el número o código Unicode al que queremos hacer referencia, y el método nos devolverá un <span class="span_tag span_string">STRING</span> con el carácter Unicode en cuestión:</p>
                  <pre><code class="language-javascript">String.fromCharCode(65); // 'A' (65 es el código U+0041 en decimal)
String.fromCharCode(0x0041); // 'A' (0x0041 es el código U+0041 en hexadecimal)
"A".charCodeAt(0); // 65
"A".charCodeAt(0).toString(16); // 41	</code></pre>
                  <p>Por otro lado, el método charCodeAt() es la operación inversa a String.fromCharCode() con algún extra. A charCodeAt(pos) le pasamos una posición con pos por parámetro. Esto buscará el carácter de la posición pos del <span class="span_tag span_string">STRING</span> y nos devolverá su código Unicode (por defecto, en decimal). Si queremos pasarlo a otra base numérica, podemos hacer uso del método toString(base) indicando 16 como base.</p>
                  <p>Observa a continuación que, los famosos emojis (por ejemplo), son realmente una combinación de 2 códigos Unicode:</p>
                  <pre><code class="language-javascript">// El valor unicode del emoji 🐦 es (55357, 56358)
emoji = "🐦";
codigos = [];
for (let i = 0; i < emoji.length; i++) {
	codigos.push(emoji.charCodeAt(i));
}
String.fromCharCode(...codigos); // '🐦' (Usamos desestructuración, ver más adelante)</code></pre>
                  <p>Observa que modificando el último código Unicode, podemos obtener diferentes emojis:</p>
                  <pre><code class="language-javascript">String.fromCharCode(55357, 56358); // '🐦'
String.fromCharCode(55357, 56359); // '🐧'
String.fromCharCode(55357, 56360); // '🐨'
("\u0041"); // 'A'
("\ud83d\udc28"); // '🐨'</code></pre>
                  <p>Una forma rápida de escribir carácteres Unicode es utilizando la secuencia de escape \u seguida del código Unicode en hexadecimal del caracter en cuestión, como se ve en los dos últimos ejemplos anteriores.</p>
                  <h4>Interpolación de variables</h4>
                  <p>En ECMAScript <strong>ES2015</strong> se introduce una interesante mejora en la manipulación general de <span class="span_tag span_string">STRING</span>, sobre todo respecto a la legibilidad de código.</p>
                  <p>Hasta ahora, si queríamos concatenar el valor de algunas variables con textos predefinidos por nosotros, teníamos que hacer algo parecido a esto:</p>
                  <pre><code class="language-javascript">const sujeto = "frase";
const adjetivo = "concatenada";
"Una " + sujeto + " bien " + adjetivo; // 'Una frase bien concatenada'</code></pre>
                  <p>A medida que añadimos más variables, el código se hace bastante menos claro y más complejo de leer, especialmente si tenemos que añadir arrays, introducir comillas simples que habría que escapar con \' o combinar comillas simples con dobles, etc...</p>
                  <p>Para evitarlo, se introducen las backticks (comillas hacia atrás), que nos permiten interpolar el valor de las variables sin tener que cerrar, concatenar y abrir la cadena de texto continuamente:</p>
                  <pre><code class="language-javascript">const sujeto = "frase";
const adjetivo = "concatenada";
`Una ${sujeto} mejor ${adjetivo}`; // 'Una frase mejor concatenada'</code></pre>
                  <p>Esto es una funcionalidad muy simple, pero que mejora sustancialmente la calidad de código generado. Eso sí, recuerda que se introduce en ECMAScript 6, con todo lo que ello conlleva.						</p>
                </div>
                <div class="section__theme section__theme--12">
                  <h2>Taciti orci torquent
                  </h2>
                  <p>Nunc tristique condimentum imperdiet quisque convallis velit etiam donec class. Urna pharetra netus risus ut tortor elit magna proin nulla. Inceptos donec vitae faucibus pharetra pulvinar consectetur tristique litora vulputate. Risus ultricies conubia purus torquent euismod scelerisque etiam orci interdum dui convallis posuere pharetra nisl.
                  </p>
                  <p>Eu sed lectus curabitur nec tristique ad eget quis suscipit. Pharetra morbi etiam aliquam rutrum arcu nam quisque cursus eleifend etiam tempus dui dapibus ultricies.
                  </p>
                  <p>Vitae pulvinar placerat posuere facilisis donec colus dictumst ornare neque. Vestibulum bibendum mi porttitor aenean felis per hendrerit conubia purus. Consequat arcu fringilla ornare arcu odio conubia ut class pharetra senectus lobortis mollis congue malesuada.
                  </p>
                  <p>Suspendisse fermentum habitant ut ac eu pretium enim turpis interdum himenaeos justo lacinia porttitor urna.
                  </p>
                  <p>Semper nullam dapibus vitae ante bibendum etiam curabitur risus felis. Porttitor platea velit magna euismod faucibus viverra mauris a taciti. Et semper maecenas quisque feugiat hac nullam purus metus conubia eleifend arcu hendrerit per tellus.
                  </p>
                  <p>Eget erat pretium ultricies dapibus duis elementum in arcu donec. Accumsan vulputate facilisis convallis duis primis eros commodo lectus sodales. Curae magna tempor mattis per mi consectetur aliquet quisque cras. Tellus massa vestibulum auctor viverra inceptos suscipit hendrerit elit viverra ligula fusce nulla viverra felis.
                  </p>
                  <p>Congue eleifend mauris a placerat nam himenaeos fermentum vivamus ligula. Est primis hendrerit lobortis tristique dui massa dapibus consequat purus inceptos orci ut class tortor.
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
  </body>
</html>